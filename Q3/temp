#计算衰减系数
# def calculate_attenuation_coefficient(beta,d=10): 
    
#     # 计算衰减系数 ,其为自然对数的底的-beta次方
#     attenuation_coefficient = np.exp(-beta*d)
  
#     return attenuation_coefficient

#测试代码
# image = cv2.imread('standrd.png') 
#     # # 估计背景光 
# background_light = estimate_background_light_local(image) 
# print(f'Estimated Background Light: {background_light}')

import cv2
import numpy as np
from skimage.segmentation import slic, mark_boundaries
from skimage.color import rgb2gray
import matplotlib.pyplot as plt
import os
import csv

def estimate_background_light_local(img, mask_01, segments):
    # 计算图像整体亮度均值
    background_light = np.mean(img)

    # 标记点标红
    marked_img = img.copy()
    marked_img[mask_01] = [255, 0, 0]

    # 标出所有超像素块的轮廓
    marked_img = mark_boundaries(marked_img, segments, color=(0, 1, 0))

    # plt.imshow(marked_img)
    # plt.title('Superpixel Segmentation with Marked Points')
    # plt.axis('off')
    # plt.show()

    # 计算结果超像素块所有的标记点三通道的均值
    if np.any(mask_01):
        color_background_light = np.mean(img[mask_01], axis=0)
    else:
        color_background_light = np.mean(img, axis=(0, 1))

    print(color_background_light)

    return background_light, marked_img, color_background_light

# 示例调用
# if __name__ == "__main__":
#     # 使用绝对路径
#     img_path = os.path.abspath('standrd.png')
#     img = cv2.imread(img_path)
#     if img is None:
#         print(f"Error: Unable to load image at {img_path}")
#     else:
#         img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
#         mask_01 = np.random.randint(0, 2, img.shape[:2], dtype=bool)
#         segments = np.random.randint(0, 10, img.shape[:2], dtype=int)
#         background_light, marked_img, color_background_light = estimate_background_light_local(img, mask_01, segments)
#         print("Background Light:", background_light)
#         print("Color Background Light:", color_background_light)